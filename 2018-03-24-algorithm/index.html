<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Algotithm | 回音壁 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Tiberius">
    
    

    <meta name="description" content="1冒泡排序它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 时间复杂度：O(n^2) 空间复杂度：O(1)12345678def bubble_sort(lists):  # 冒泡排序  count = len(lists)  for i in range(0, count):    for">
<meta name="keywords" content="algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="Algotithm | 回音壁">
<meta property="og:url" content="http://yoursite.com/2018-03-24-algorithm/index.html">
<meta property="og:site_name" content="回音壁">
<meta property="og:description" content="1冒泡排序它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 时间复杂度：O(n^2) 空间复杂度：O(1)12345678def bubble_sort(lists):  # 冒泡排序  count = len(lists)  for i in range(0, count):    for">
<meta property="og:locale" content="zh_cn">
<meta property="og:updated_time" content="2018-03-27T15:44:23.027Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Algotithm | 回音壁">
<meta name="twitter:description" content="1冒泡排序它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 时间复杂度：O(n^2) 空间复杂度：O(1)12345678def bubble_sort(lists):  # 冒泡排序  count = len(lists)  for i in range(0, count):    for">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">回音壁</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          一切爆发都有片刻的宁静/一切死亡都有冗长的回声
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Algotithm</h1>

    

    <div class="post-meta">
      <time datetime="2018-03-24" class="post-meta__date date">2018-03-24</time> 

      <span class="post-meta__tags tags">

          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="/categories/python/">python</a>
            </font>
          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/algorithm/">algorithm</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h1 id="1冒泡排序"><a href="#1冒泡排序" class="headerlink" title="1冒泡排序"></a>1冒泡排序</h1><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<h4 id="时间复杂度：O-n-2-空间复杂度：O-1"><a href="#时间复杂度：O-n-2-空间复杂度：O-1" class="headerlink" title="时间复杂度：O(n^2) 空间复杂度：O(1)"></a>时间复杂度：O(n^2) 空间复杂度：O(1)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(lists)</span>:</span></span><br><span class="line">  <span class="comment"># 冒泡排序</span></span><br><span class="line">  count = len(lists)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, count):</span><br><span class="line">      <span class="keyword">if</span> lists[i] &gt; lists[j]:</span><br><span class="line">        lists[i], lists[j] = lists[j], lists[i]</span><br><span class="line">  <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>
<h1 id="2选择排序"><a href="#2选择排序" class="headerlink" title="2选择排序"></a>2选择排序</h1><p>基本思想：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。</p>
<h4 id="时间复杂度：O-n-2-空间复杂度：O-1-1"><a href="#时间复杂度：O-n-2-空间复杂度：O-1-1" class="headerlink" title="时间复杂度：O(n^2) 空间复杂度：O(1)"></a>时间复杂度：O(n^2) 空间复杂度：O(1)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(lists)</span>:</span></span><br><span class="line">  <span class="comment"># 选择排序</span></span><br><span class="line">  count = len(lists)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">    min = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, count):</span><br><span class="line">      <span class="keyword">if</span> lists[min] &gt; lists[j]:</span><br><span class="line">        min = j</span><br><span class="line">    lists[min], lists[i] = lists[i], lists[min]</span><br><span class="line">  <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>
<h1 id="3插入排序"><a href="#3插入排序" class="headerlink" title="3插入排序"></a>3插入排序</h1><p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据,</p>
<h4 id="时间复杂度：O-n-2-空间复杂度：O-1-2"><a href="#时间复杂度：O-n-2-空间复杂度：O-1-2" class="headerlink" title="时间复杂度：O(n^2) 空间复杂度：O(1)"></a>时间复杂度：O(n^2) 空间复杂度：O(1)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(lists)</span>:</span></span><br><span class="line">  <span class="comment"># 插入排序</span></span><br><span class="line">  count = len(lists)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, count):</span><br><span class="line">    key = lists[i]</span><br><span class="line">    j = i - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">if</span> lists[j] &gt; key:</span><br><span class="line">        lists[j + <span class="number">1</span>] = lists[j]</span><br><span class="line">        lists[j] = key</span><br><span class="line">      j -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>
<h1 id="4希尔排序"><a href="#4希尔排序" class="headerlink" title="4希尔排序"></a>4希尔排序</h1><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h4 id="时间复杂度：O-nlogn-空间复杂度：O-1"><a href="#时间复杂度：O-nlogn-空间复杂度：O-1" class="headerlink" title="时间复杂度：O(nlogn) 空间复杂度：O(1)"></a>时间复杂度：O(nlogn) 空间复杂度：O(1)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(lists)</span>:</span></span><br><span class="line">  <span class="comment"># 希尔排序</span></span><br><span class="line">  count = len(lists)</span><br><span class="line">  step = <span class="number">2</span></span><br><span class="line">  group = count / step</span><br><span class="line">  <span class="keyword">while</span> group &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, group):</span><br><span class="line">      j = i + group</span><br><span class="line">      <span class="keyword">while</span> j &lt; count:</span><br><span class="line">        k = j - group</span><br><span class="line">        key = lists[j]</span><br><span class="line">        <span class="keyword">while</span> k &gt;= <span class="number">0</span>:</span><br><span class="line">          <span class="keyword">if</span> lists[k] &gt; key:</span><br><span class="line">            lists[k + group] = lists[k]</span><br><span class="line">            lists[k] = key</span><br><span class="line">          k -= group</span><br><span class="line">        j += group</span><br><span class="line">    group /= step</span><br><span class="line">  <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>
<h1 id="5归并排需"><a href="#5归并排需" class="headerlink" title="5归并排需"></a>5归并排需</h1><p>归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</p>
<h4 id="时间复杂度：O-nlogn-空间复杂度：O-n"><a href="#时间复杂度：O-nlogn-空间复杂度：O-n" class="headerlink" title="时间复杂度：O(nlogn) 空间复杂度：O(n)"></a>时间复杂度：O(nlogn) 空间复杂度：O(n)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">  i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  result = []</span><br><span class="line">  <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">    <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">      result.append(left[i])</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      result.append(right[j])</span><br><span class="line">      j += <span class="number">1</span></span><br><span class="line">  result += left[i:]</span><br><span class="line">  result += right[j:]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(lists)</span>:</span></span><br><span class="line">  <span class="comment"># 归并排序</span></span><br><span class="line">  <span class="keyword">if</span> len(lists) &lt;= <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> lists</span><br><span class="line">  num = len(lists) / <span class="number">2</span></span><br><span class="line">  left = merge_sort(lists[:num])</span><br><span class="line">  right = merge_sort(lists[num:])</span><br><span class="line">  <span class="keyword">return</span> merge(left, right)</span><br></pre></td></tr></table></figure>
<h1 id="6快速排序"><a href="#6快速排序" class="headerlink" title="6快速排序"></a>6快速排序</h1><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<h4 id="时间复杂度：O-nlogn-空间复杂度：O-logn"><a href="#时间复杂度：O-nlogn-空间复杂度：O-logn" class="headerlink" title="时间复杂度：O(nlogn) 空间复杂度：O(logn)"></a>时间复杂度：O(nlogn) 空间复杂度：O(logn)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(lists, left, right)</span>:</span></span><br><span class="line">  <span class="comment"># 快速排序</span></span><br><span class="line">  <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">    <span class="keyword">return</span> lists</span><br><span class="line">  key = lists[left]<span class="comment">#最左边的值</span></span><br><span class="line">  low = left <span class="comment">#最低的id</span></span><br><span class="line">  high = right <span class="comment">#最高的id</span></span><br><span class="line">  <span class="keyword">while</span> left &lt; right:</span><br><span class="line">    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> lists[right] &gt;= key:</span><br><span class="line">      right -= <span class="number">1</span><span class="comment">#从右边找到大于左边的</span></span><br><span class="line">    lists[left] = lists[right]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> lists[left] &lt;= key:</span><br><span class="line">      left += <span class="number">1</span><span class="comment">#从左边找到小于右边的</span></span><br><span class="line">    lists[right] = lists[left]</span><br><span class="line">  lists[right] = key</span><br><span class="line">  quick_sort(lists, low, left - <span class="number">1</span>)</span><br><span class="line">  quick_sort(lists, left + <span class="number">1</span>, high)</span><br><span class="line">  <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>
<h1 id="7堆排序"><a href="#7堆排序" class="headerlink" title="7堆排序"></a>7堆排序</h1><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>
<h4 id="时间复杂度：O-nlogn-空间复杂度：O-1-1"><a href="#时间复杂度：O-nlogn-空间复杂度：O-1-1" class="headerlink" title="时间复杂度：O(nlogn) 空间复杂度：O(1)"></a>时间复杂度：O(nlogn) 空间复杂度：O(1)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span><span class="params">(lists, i, size)</span>:</span> <span class="comment">#调整堆</span></span><br><span class="line">  lchild = <span class="number">2</span> * i + <span class="number">1</span>  <span class="comment">#左子节点</span></span><br><span class="line">  rchild = <span class="number">2</span> * i + <span class="number">2</span>  <span class="comment">#右子节点</span></span><br><span class="line">  max = i  <span class="comment">#父节点</span></span><br><span class="line">  <span class="keyword">if</span> i &lt; size / <span class="number">2</span>: <span class="comment">#父节点非叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> lchild &lt; size <span class="keyword">and</span> lists[lchild] &gt; lists[max]:</span><br><span class="line">      max = lchild <span class="comment">#左叶子节点比父节点大</span></span><br><span class="line">    <span class="keyword">if</span> rchild &lt; size <span class="keyword">and</span> lists[rchild] &gt; lists[max]:</span><br><span class="line">      max = rchild <span class="comment">#右叶子节点比父节点大</span></span><br><span class="line">    <span class="keyword">if</span> max != i: <span class="comment">#父节点不是最大</span></span><br><span class="line">      lists[max], lists[i] = lists[i], lists[max]</span><br><span class="line">      adjust_heap(lists, max, size) <span class="comment">#父节点变化重新调整</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_heap</span><span class="params">(lists, size)</span>:</span> <span class="comment">#创建堆</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, (size/<span class="number">2</span>))[::<span class="number">-1</span>]: <span class="comment">#从非叶子节点底部开始调整</span></span><br><span class="line">    adjust_heap(lists, i, size) </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(lists)</span>:</span></span><br><span class="line">  size = len(lists)</span><br><span class="line">  build_heap(lists, size) <span class="comment">#堆排序</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size)[::<span class="number">-1</span>]:</span><br><span class="line">    lists[<span class="number">0</span>], lists[i] = lists[i], lists[<span class="number">0</span>] <span class="comment">#顶部为最大值放到最后</span></span><br><span class="line">    adjust_heap(lists, <span class="number">0</span>, i) <span class="comment">#重新调整剩余元素</span></span><br></pre></td></tr></table></figure>
<h1 id="8计数排序"><a href="#8计数排序" class="headerlink" title="8计数排序"></a>8计数排序</h1><p>假设n个输入元素中每一个都是介于0到k之间的整数，此处k为某个整数。当k=O(n)时，计数排序的运行时间为Θ(n)。对每一个数的元素x，确定出小于x的元素个数。有了这一信息就可以把x直接放到最终输出数组中的位置上。</p>
<h4 id="时间复杂度：O-n-k-空间复杂度：O-k"><a href="#时间复杂度：O-n-k-空间复杂度：O-k" class="headerlink" title="时间复杂度：O(n+k) 空间复杂度：O(k)"></a>时间复杂度：O(n+k) 空间复杂度：O(k)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countingSort</span><span class="params">(alist,k)</span>:</span></span><br><span class="line">  n=len(alist)</span><br><span class="line">  b=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)] <span class="comment">#结果数组</span></span><br><span class="line">  c=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k+<span class="number">1</span>)] <span class="comment">#范围数组</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> alist:</span><br><span class="line">    c[i]+=<span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>,len(c)):</span><br><span class="line">    c[i]=c[i<span class="number">-1</span>]+c[i] <span class="comment">#累加</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> alist:</span><br><span class="line">    b[c[i]<span class="number">-1</span>]=i <span class="comment">#c[i]为alist中i的个数</span></span><br><span class="line">    c[i]-=<span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">  a=[random.randint(<span class="number">0</span>,<span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">100</span>)]</span><br><span class="line">  <span class="keyword">print</span> countingSort(a,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h1 id="9桶排序"><a href="#9桶排序" class="headerlink" title="9桶排序"></a>9桶排序</h1><p>如果有一个数组A，包含N个整数，值从1到M，我们可以得到一种非常快速的排序，桶排序（bucket sort）。留置一个数组S，里面含有M个桶，初始化为0。然后遍历数组A，读入Ai时，S[Ai]增一。所有输入被读进后，扫描数组S得出排好序的表。该算法时间花费O(M+N)，空间上不能原地排序。</p>
<h4 id="时间复杂度：O-n-k-空间复杂度：O-n-k"><a href="#时间复杂度：O-n-k-空间复杂度：O-n-k" class="headerlink" title="时间复杂度：O(n+k) 空间复杂度：O(n+k)"></a>时间复杂度：O(n+k) 空间复杂度：O(n+k)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>:</span>  <span class="comment">#桶节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,k)</span>:</span>  </span><br><span class="line">    self.key=k;  </span><br><span class="line">    self.next=<span class="keyword">None</span>;  <span class="comment">#指针</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketsort</span><span class="params">(lista)</span>:</span>  </span><br><span class="line">  <span class="comment">#初始化10个桶</span></span><br><span class="line">  h=[];  </span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):  </span><br><span class="line">    h.append(node(<span class="number">0</span>)); </span><br><span class="line">  <span class="comment">#遍历节点 </span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(lista)):  </span><br><span class="line">    tmp=node(lista[i]);  </span><br><span class="line">    map=lista[i]/<span class="number">10</span>;  </span><br><span class="line">    p=h[map];<span class="comment">#找到对应的桶  </span></span><br><span class="line">    <span class="keyword">if</span> p.key <span class="keyword">is</span> <span class="number">0</span>:  <span class="comment">#空</span></span><br><span class="line">      h[map].next=tmp;  </span><br><span class="line">      h[map].key=h[map].key+<span class="number">1</span>; <span class="comment">#桶中数量加一 </span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment">#已存在节点</span></span><br><span class="line">      <span class="keyword">while</span>(p.next !=<span class="keyword">None</span> <span class="keyword">and</span> p.next.key&lt;=tmp.key):<span class="comment">#桶中的值小于插入值  </span></span><br><span class="line">        p=p.next;  </span><br><span class="line">      tmp.next=p.next;  </span><br><span class="line">      p.next=tmp;  <span class="comment">#插入节点</span></span><br><span class="line">      h[map].key=h[map].key+<span class="number">1</span>;  </span><br><span class="line">  k=<span class="number">0</span>;  </span><br><span class="line">  <span class="comment">#遍历桶</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):  </span><br><span class="line">    q=h[i].next;  </span><br><span class="line">    <span class="keyword">while</span>(q != <span class="keyword">None</span> ):  </span><br><span class="line">      lista[k]=q.key;  </span><br><span class="line">      k=k+<span class="number">1</span>;  </span><br><span class="line">      q=q.next;  </span><br><span class="line">  <span class="keyword">return</span> lista;  </span><br><span class="line">lista=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="number">97</span>,<span class="number">22</span>,<span class="number">10</span>,<span class="number">4</span>];   <span class="comment">#桶排序测试代码  </span></span><br><span class="line">bucketsort(lista);  </span><br><span class="line"><span class="keyword">print</span> lista;</span><br></pre></td></tr></table></figure>
<h1 id="10基数排序"><a href="#10基数排序" class="headerlink" title="10基数排序"></a>10基数排序</h1><p>基数排序一般用于长度相同的元素组成的数组。首先按照最低有效数字进行排序，然后由低位向高位进行。基数排序可以看做是进行多趟桶排序。每个有效数字都在0-9之间，很适合桶排序，建10个桶很方便。</p>
<h4 id="时间复杂度：O-n-k-空间复杂度：O-n-k-1"><a href="#时间复杂度：O-n-k-空间复杂度：O-n-k-1" class="headerlink" title="时间复杂度：O(n*k) 空间复杂度：O(n+k)"></a>时间复杂度：O(n*k) 空间复杂度：O(n+k)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(lists, radix=<span class="number">10</span>)</span>:</span></span><br><span class="line">  k = int(math.ceil(math.log(max(lists), radix)))</span><br><span class="line">  bucket = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(radix)]</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> lists:</span><br><span class="line">      bucket[j/(radix**(i<span class="number">-1</span>)) % (radix**i)].append(j)</span><br><span class="line">    <span class="keyword">del</span> lists[:]</span><br><span class="line">    <span class="keyword">for</span> z <span class="keyword">in</span> bucket:</span><br><span class="line">      lists += z</span><br><span class="line">      <span class="keyword">del</span> z[:]</span><br><span class="line">  <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>
<h1 id="深度优先遍历（scrapy）"><a href="#深度优先遍历（scrapy）" class="headerlink" title="深度优先遍历（scrapy）"></a>深度优先遍历（scrapy）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth_tree</span><span class="params">(node)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">    <span class="keyword">print</span> node.data</span><br><span class="line">    <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">      <span class="keyword">return</span> deep_tree(node.left)</span><br><span class="line">    <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">      <span class="keyword">return</span> deep_tree(node.right)</span><br><span class="line">```   </span><br><span class="line"><span class="comment"># 广度优先遍历</span></span><br><span class="line">```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_queue</span><span class="params">(root)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> root <span class="keyword">is</span> NOne:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  queue=[]</span><br><span class="line">  node=root</span><br><span class="line">  queue.append(node)</span><br><span class="line">  <span class="keyword">while</span> queue:</span><br><span class="line">    node=queue.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">print</span> node.elem</span><br><span class="line">    <span class="keyword">if</span> node.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">      queue.append(node.lchild)</span><br><span class="line">    <span class="keyword">if</span> node.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">      queue.append(node.echild)</span><br></pre></td></tr></table></figure>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
